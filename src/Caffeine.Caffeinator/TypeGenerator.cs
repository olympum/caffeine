/*
 * Copyright (C) 2004 Bruno Fernandez-Ruiz <brunofr@olympum.com>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
namespace Caffeine.Caffeinator
{
	using System;
	using System.Collections;
	using System.Reflection;
	using System.Reflection.Emit;
	
	public class TypeGenerator
	{
		ClassFactory factory;
		Hashtable tpBldCache;
		Hashtable typeCache;
		PEemitter emitter;
		
		public TypeGenerator(PEemitter emitter, ClassFactory factory)
		{
			this.emitter = emitter;
			this.factory = factory;
			tpBldCache = new Hashtable();
			typeCache = new Hashtable();
			// populate basic types
			typeCache["byte"] = typeof(byte);
			typeCache["char"] = typeof(char);
			typeCache["double"] = typeof(double);
			typeCache["float"] = typeof(float);
			typeCache["int"] = typeof(int);
			typeCache["long"] = typeof(long);
			typeCache["short"] = typeof(short);
			typeCache["bool"] = typeof(bool);
			typeCache["void"] = typeof(void);			
		}
		
		public void Generate(Class c)
		{
			TypeBuilder tBuilder = (TypeBuilder) GetType(c);
			if (tBuilder == null) {
				// parent, or interface is not
				// public namespace, or inner
				return;
			}
			
			// Parent and implemented interfaces
			Generate(ref tBuilder, c);
			
			// fields
			foreach (Field f in c.Fields) {
				Generate(ref tBuilder, f);
			}
			
			// constructors and methods
			foreach (Method m in c.Methods) {
				Generate(ref tBuilder, m);
			}
		}
		
		public void EndTypes()
		{
			// two passes, first one completing enclosing types, second pass
			// completing nested types
			
			foreach (DictionaryEntry e in tpBldCache) {
				TypeBuilder t = (TypeBuilder) e.Value;
				if (t.DeclaringType != null) {
					// we must create the enclosing type before
					// the nested type
					Console.WriteLine("Skipping over {0}", t.FullName);
					return;
				}
				t.CreateType();
				Console.WriteLine("Created type {0}", t);
			}
		}
		
		public void AddType(Class c)
		{
			//if (c.FullyQualifiedName.CompareTo("internal")>0){
			//	return;
			//}
			
			/*
			 * we only add public namespace types, inner types get 
			 * automatically generated by recursion
			 */
			if (c.DeclaringClass != null) {
				Console.WriteLine("INFO: skipped inner {0}",
					c.FullyQualifiedName);
				return;
			}
			
			if (!c.IsPublic) {
				Console.WriteLine("INFO: skipped non-public {0}",
					c.FullyQualifiedName);
				return;
			}
			
			TypeBuilder tBuilder
				= (TypeBuilder) tpBldCache[c.FullyQualifiedName];
			if (tBuilder != null) {
				throw new ApplicationException("Duplicate type :" +
					tBuilder.FullName);
			}
			
			/*
			 * FIXME!!
			 * We force all inner types to be public
			 * because we are not parsing the
			 * InnerAttribute in ClassFile.
			 * If we were doing it, we could specifiy the
			 * visibility of the Nested class (Family,
			 * Assembly, Public), and skip Private.
			 *
			 */
			TypeAttributes attrs = c.TypeAttributes;
			if (c.DeclaringClass != null && !c.IsPublic) {
				attrs |= TypeAttributes.Public;
			}
			
			tBuilder = emitter.BeginType(c.FullyQualifiedName, attrs);
			tpBldCache[tBuilder.FullName] = tBuilder;
			Console.WriteLine("DEBUG: Defined type {0}", tBuilder.FullName);
			// nested types
			foreach (Class innerClass in c.InnerTypes) {				
				/*
				 * do not generate anonymous types, e.g. x/y/z/A$1
				 */
				if (Char.IsDigit(innerClass.Name[0])) {
					continue;
				}
				
				/*
				 * FIXME!!
				 * We force all inner types to be public
				 * because we are not parsing the
				 * InnerAttribute in ClassFile.
				 * If we were doing it, we could specifiy the
				 * visibility of the Nested class (Family,
				 * Assembly, Public), and skip Private.
				 *
				 */
				attrs = TypeAttributes.NestedPublic
					| innerClass.TypeAttributes;
				// as a nested type we don't need the namespace
				// and parent type, instead of FullName we
				// simply use the name
				TypeBuilder nested = tBuilder.DefineNestedType(
					innerClass.Name, 
					attrs);
				tpBldCache[nested.FullName] = nested;
				Console.WriteLine("DEBUG: Defined inner type {0}",
					nested.FullName);
			}
		}
		
		void Generate(ref TypeBuilder tBuilder, Class c)
		{
			// parent and interfaces
			foreach (Class baseType in c.BaseTypes) {
				Type t = GetType(baseType);
				if (t == null) {
					// parent, or interface is not
					// public namespace, or inner
					Console.WriteLine("WARNING: skipped base type {0} for {1}",
						baseType, tBuilder.FullName);
					continue;
				}
				if (baseType.IsInterface) {
					tBuilder.AddInterfaceImplementation(t);
				} else {
					tBuilder.SetParent(t);
				}
			}
		}
		
		void Generate(ref TypeBuilder tBuilder, Field f)
		{
			// TODO emit field
		}
		
		void Generate(ref TypeBuilder tBuilder, Method m)
		{
			if (m.IsPrivate) {
				return;
			}
			
			MethodAttributes attr = m.MethodAttributes;
			
			Descriptor[] args = m.Arguments;
			Type[] parameterTypes = new Type[args.Length];
			for (int i = 0; i < args.Length; i++) {
				Type t = GetType(args[i]);
				if (t == null) {
					// the type is not in the cache
					// so we can skip the whole method
					Console.WriteLine("WARNING: skipped method {0} in {1}",
						m, tBuilder);
					return;
				}
				parameterTypes[i] = t;
			}
			
			Type returnType = GetType(m.Return);
			if (returnType == null) {
				// the type is not in the cache
				// so we can skip the whole method
				Console.WriteLine("WARNING: skipped method {0} in {1}",
					m, tBuilder);
				return;
			}
			
			string mName = m.Name;
			
			if (mName.Equals("<init>") || mName.Equals("<clinit>")) {
				// TODO emit constructor
				return;
			}
			
			MethodBuilder mBuilder = tBuilder.DefineMethod(
				mName,
				attr,
				returnType, 
				parameterTypes);
			
			// no implementation for interfaces
			if (tBuilder.IsInterface) {
				return;
			}
			
			// at least generate a return (to make method valid)
			ILGenerator methodIL = mBuilder.GetILGenerator();
			// TODO emit real method code
			methodIL.Emit(OpCodes.Ret);			
		}
		
		Type GetType(Descriptor arg)
		{
			int rank = arg.GetArrayRank();
			Class eType = arg.GetElementType();
			Type t = GetType(eType);
			if (rank > 0) {
				if (t == null) {
					return null;
				}
				string suffix = "";
				for (int i = 0; i < rank; i++) {
					suffix += "[]";
				}
				Type temp = Type.GetType(t.AssemblyQualifiedName);
				if (temp == null) {
					Console.WriteLine("ERROR: type not found {0}", t.AssemblyQualifiedName);
				}
				t = Type.GetType(t.AssemblyQualifiedName + suffix);
			}
			if (t == null) {
				Console.WriteLine("Type not found {0}, class {1}, rank {2}", arg, eType, rank);
			}
			return t;
		}
		
		Type GetType(Class c)
		{
			object r = typeCache[c.FullyQualifiedName];
			if (r != null) {
				return (Type) r;
			}
			return (Type) tpBldCache[c.FullyQualifiedName];
		}
	}
}
